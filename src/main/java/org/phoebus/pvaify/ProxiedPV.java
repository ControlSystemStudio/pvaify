/*******************************************************************************
 * Copyright (c) 2025 Oak Ridge National Laboratory.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 ******************************************************************************/
package org.phoebus.pvaify;

import static org.phoebus.pvaify.Proxy.logger;

import java.util.concurrent.atomic.AtomicReference;
import java.util.logging.Level;

import org.epics.pva.data.PVAStructure;
import org.epics.pva.server.ServerPV;
import org.epics.vtype.VType;
import org.phoebus.pv.PV;
import org.phoebus.pv.PVPool;

import io.reactivex.rxjava3.disposables.Disposable;

/** One PV that's proxied to PVA
 *  @author Kay Kasemir
 */
class ProxiedPV
{
    private final Proxy proxy;

    private final String name;

    private enum State
    {
        /** Just created, needs to be started */
        Created,
        /** Started client side, awaiting first value */
        Started,
        /** Created server PV with value, have not seen any client on the server side */
        FreshServer,
        /** Server has proxied at least one update, there was a client to the server side */
        Active,
        /** Closing server and client end down */
        Disposed
    }

    /** Proxy lifecycle state */
    private AtomicReference<State> state = new AtomicReference<>(State.Created);

    /** Client PV from which we proxy data to server PV */
    private volatile PV client_pv;

    /** Subscription to updates from the client PV */
    private Disposable client_sub;

    /** PVA PV that's being generated by this proxy */
    private ServerPV server_pv;

    /** Most recent value that's being forwarded to server PV */
    private PVAStructure server_data;

    ProxiedPV(final Proxy proxy, final String name)
    {
        logger.log(Level.FINE, () -> ">>>>>>>>>> Creating proxy: " + name);
        this.proxy = proxy;
        this.name = name;
    }

    void start() throws Exception
    {
        if (state.compareAndSet(State.Created, State.Started))
        {
            // Create the client PV
            client_pv = PVPool.getPV(name);
            // Subscribe to updates
            // On first update, when data type is known, create the server PV
            client_sub = client_pv.onValueEvent().subscribe(value -> handleClientUpdate(name, value));
        }
    }

    /** @return PV name */
    public String getName()
    {
        return name;
    }

    /** @return Is the proxy connected on the client side? */
    public boolean isConnected()
    {
        final PV safe_pv = client_pv;
        if (safe_pv == null)
            return false;
        VType value = safe_pv.read();
        if (PV.isDisconnected(value))
            return false;
        return true;
    }

    /** Handle a client PV update
     *  Create PVA PV on first update, then keep updating its value
     *  @param name PV name
     *  @param value Value received on client side
     */
    private void handleClientUpdate(final String name, final VType value)
    {
        logger.log(Level.FINE, "Client: " + name + " = " + value + " [" + state.get() + "]");
        if (state.get() == State.Disposed)
        {
            logger.log(Level.FINE, "Client: " + name + " update ignored, proxy has been disposed");
            return;
        }

        try
        {
            // If this is the first update, create server PV with that initial value
            if (state.compareAndSet(State.Started, State.FreshServer))
                server_pv = createServerPV(name, value);
            else
            {
                // Update server's PV data from received value
                DataUtil.update(server_data, value);
                logger.log(Level.FINER, () -> "Sending update : " + server_data);
                server_pv.update(server_data);

                // Do we have at least one client to our server side?
                if (server_pv.isSubscribed())
                {
                    // Yes, then we're active
                    state.set(State.Active);
                }
                else if (state.get() == State.Active)
                {
                    // We were active, but nobody is interested any longer.
                    logger.log(Level.FINER, () -> "Removing unused proxy: " + name);
                    close();
                }
            }
        }
        catch (Exception ex)
        {
            logger.log(Level.WARNING, "Cannot update server PV " + name + " for " + value, ex);
            close();
        }
    }

    /** Create PVA server PV with initial value
     *  @param name PV name
     *  @param value Initial value
     *  @return {@link ServerPV}
     * @throws Exception on error
     */
    private ServerPV createServerPV(final String name, final VType value) throws Exception
    {
        server_data = DataUtil.create(name, value);
        return proxy.server.createPV(name, server_data);
    }

    private void close()
    {
        // TODO Correct order of cleanup?

        // Mark as disposed so further client updates will be ignored
        state.set(State.Disposed);

        // Proxy is unused right now, but there could be a new request on the way...
        // Unregister so further requests will create a new proxy
        proxy.forgetProxiedPV(this);

        // Now that this proxy is basically orphaned, stop client ...
        if (client_sub != null)
            client_sub.dispose();
        if (client_pv != null)
            PVPool.releasePV(client_pv);
        // ... then server side (if we got as far as creating one)
        if (server_pv != null)
            server_pv.close();

        logger.log(Level.FINE, () -> "<<<<<<<<<< Disposed proxy: " + getName() + "\n\n\n");
    }

    @Override
    public String toString()
    {
        return "ProxyPV '" + name + "', " + state.get();
    }
}
