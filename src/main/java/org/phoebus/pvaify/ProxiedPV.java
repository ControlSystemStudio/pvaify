/*******************************************************************************
 * Copyright (c) 2025 Oak Ridge National Laboratory.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 ******************************************************************************/
package org.phoebus.pvaify;

import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;
import java.util.logging.Level;

import org.epics.pva.data.PVAStructure;
import org.epics.pva.server.PVAServer;
import org.epics.pva.server.ServerPV;
import org.epics.vtype.VType;
import org.phoebus.pv.PV;
import org.phoebus.pv.PVPool;

import io.reactivex.rxjava3.disposables.Disposable;

import static org.phoebus.pvaify.Main.logger;

/** One PV that's proxied to PVA
 *  @author Kay Kasemir
 */
public class ProxiedPV
{
    /** PVA server side of this converter: Detects searches, provides PVA PVs */
    static PVAServer server;

    private enum State
    {
        /** Created client side, awaiting first value */
        ClientOnly,
        /** Created server PV with value, have not seen any client on the server side.
         *  Might be in this state for a while until client subscribes to the server side
         */
        FreshServer,
        /** Server has proxied at least one update, there was a client to the server side */
        Active,
        /** Closing server and client end down */
        Disposed
    }

    final Consumer<ProxiedPV> disposal_callback;

    /** Client PV from which we proxy data to server PV */
    private final PV client_pv;

    /** Subscription to updates from the client PV */
    private final Disposable client_sub;

    private AtomicReference<State> state = new AtomicReference<>(State.ClientOnly);

    /** PVA PV that's being generated by this proxy */
    private ServerPV server_pv;

    /** Most recent value that's being forwarded to server PV */
    private PVAStructure server_data;

    public ProxiedPV(final String name, final Consumer<ProxiedPV> disposal_callback) throws Exception
    {
        logger.log(Level.FINE, () -> ">>>>>>>>>> Creating proxy: " + name);
        this.disposal_callback = disposal_callback;
        // Create the client PV
        client_pv = PVPool.getPV(name);
        // Subscribe to updates
        // On first update, when data type is known, create the server PV
        client_sub = client_pv.onValueEvent().subscribe(value -> handleClientUpdate(name, value));
    }

    /** @return PV name */
    public String getName()
    {
        return client_pv.getName();
    }

    /** Handle a client PV update
     *  Create PVA PV on first update, then keep updating its value
     *  @param name PV name
     *  @param value Value received on client side
     */
    private void handleClientUpdate(final String name, final VType value)
    {
        logger.log(Level.FINE, "Client: " + name + " = " + value + " [" + state.get() + "]");
        if (state.get() == State.Disposed)
        {
            logger.log(Level.FINE, "Client: " + name + " update ignored, proxy has been disposed");
            return;
        }

        try
        {
            // If this is the first update, create server PV with that initial value
            if (state.compareAndSet(State.ClientOnly, State.FreshServer))
                server_pv = createServerPV(name, value);
            else
            {
                // Update server's PV data from received value
                DataUtil.update(server_data, value);
                logger.log(Level.FINER, () -> "Sending update : " + server_data);
                server_pv.update(server_data);

                // Do we have at least one client to our server side?
                if (server_pv.isSubscribed())
                {
                    // Yes, then we're active
                    state.set(State.Active);
                }
                else if (state.compareAndSet(State.Active, State.Disposed))
                {
                    // TODO Correct order of cleanup, including state = Disposed?

                    // We were active, but nobody is interested any longer.
                    // Mark as disposed so further client updates will be ignored
                    logger.log(Level.FINER, () -> "Removing unused proxy: " + name);

                    // Proxy is unused right now, but there could be a new request on the way...
                    // Unregister so any new requests will create a new proxy
                    disposal_callback.accept(this);
                    // Now that this proxy is basically orphaned, stop client ...
                    client_sub.dispose();
                    PVPool.releasePV(client_pv);
                    // ... then server side
                    server_pv.close();

                    logger.log(Level.FINE, () -> "<<<<<<<<<< Disposed proxy: " + name);
                }
            }
        }
        catch (Exception ex)
        {
            logger.log(Level.WARNING, "Cannot update server PV " + name + " for " + value, ex);
        }
    }

    /** Create PVA server PV with initial value
     *  @param name PV name
     *  @param value Initial value
     *  @return {@link ServerPV}
     * @throws Exception on error
     */
    private ServerPV createServerPV(final String name, final VType value) throws Exception
    {
        server_data = DataUtil.create(name, value);
        return server.createPV(name, server_data);
    }
}
