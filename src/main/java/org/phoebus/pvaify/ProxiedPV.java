/*******************************************************************************
 * Copyright (c) 2025 Oak Ridge National Laboratory.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 ******************************************************************************/
package org.phoebus.pvaify;

import java.util.concurrent.atomic.AtomicReference;
import java.util.logging.Level;

import org.epics.pva.data.PVAStructure;
import org.epics.pva.server.PVAServer;
import org.epics.pva.server.ServerPV;
import org.epics.vtype.VType;
import org.phoebus.pv.PV;
import org.phoebus.pv.PVPool;

import static org.phoebus.pvaify.Main.logger;

/** One PV that's proxied to PVA
 *  @author Kay Kasemir
 */
public class ProxiedPV
{
    /** PVA server side of this converter: Detects searches, provides PVA PVs */
    static PVAServer server;

    private enum State
    {
        /** Created client side, awaiting first value */
        Fresh,
        /** Created server PV with value, maybe updated a few times */
        Active
    }

    /** Client PV from which we proxy data to server PV */
    private final PV client_pv;

    private AtomicReference<State> state = new AtomicReference<>(State.Fresh);

    /** PVA PV that's being generated by this proxy */
    private ServerPV server_pv;

    /** Most recent value that's being forwarded to server PV */
    private PVAStructure server_data;

    public ProxiedPV(final String name) throws Exception
    {
        // Create the client PV
        client_pv = PVPool.getPV(name);
        // Subscribe to updates
        // On first update, when data type is known, create the server PV
        client_pv.onValueEvent().subscribe(value -> handleClientUpdate(name, value));
    }

    /** Handle a client PV update
     *  Create PVA PV on first update, then keep updating its value
     *  @param name PV name
     *  @param value Value received on client side
     */
    private void handleClientUpdate(final String name, final VType value)
    {
        logger.log(Level.FINE, "Client: " + name + " = " + value);

        try
        {
            // If this is the first update, create server PV with that initial value
            if (state.compareAndSet(State.Fresh, State.Active))
                server_pv = createServerPV(name, value);
            else
            {
                // Update server's PV data from received value
                DataUtil.update(server_data, value);
                logger.log(Level.FINER, () -> "Sending update : " + server_data);
                server_pv.update(server_data);

                if (! server_pv.isSubscribed())
                {
                    logger.log(Level.FINER, () -> "** Should schedule PV to be removed: " + name + " ---------------------------------------------------- *****");
    //                PV client_pv = client_pvs.remove(name);
    //                if (client_pv != null)
    //                    PVPool.releasePV(client_pv);
    //                server_pv.close();
                }
            }
        }
        catch (Exception ex)
        {
            logger.log(Level.WARNING, "Cannot update server PV " + name + " for " + value, ex);
        }
    }

    /** Create PVA server PV with initial value
     *  @param name PV name
     *  @param value Initial value
     *  @return {@link ServerPV}
     * @throws Exception on error
     */
    private ServerPV createServerPV(final String name, final VType value) throws Exception
    {
        server_data = DataUtil.create(name, value);
        return server.createPV(name, server_data);
    }
}
