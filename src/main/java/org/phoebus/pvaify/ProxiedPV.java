/*******************************************************************************
 * Copyright (c) 2025 Oak Ridge National Laboratory.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 ******************************************************************************/
package org.phoebus.pvaify;

import static org.phoebus.pvaify.Proxy.logger;

import java.net.InetSocketAddress;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;
import java.util.logging.Level;

import org.epics.pva.data.PVAStructure;
import org.epics.pva.server.ServerPV;
import org.epics.vtype.VType;
import org.phoebus.pv.PV;
import org.phoebus.pv.PVPool;

import io.reactivex.rxjava3.core.Flowable;
import io.reactivex.rxjava3.disposables.Disposable;

/** One PV that's proxied to PVA
 *  @author Kay Kasemir
 */
class ProxiedPV
{
    /** Proxy to which this PV belongs */
    private final Proxy proxy;

    /** Name of the PV */
    private final String name;

    /** Send reply to PVA client which searched for this PV */
    private final AtomicReference<Consumer<InetSocketAddress>> reply_sender = new AtomicReference<>();

    /** Proxy lifecycle state */
    private ProxiedPVState state = new ProxiedPVState();

    /** Client PV from which we proxy data to server PV */
    private volatile PV client_pv;

    /** Subscription to updates from the client PV */
    private Disposable client_sub;

    /** PVA PV that's being generated by this proxy */
    private volatile ServerPV server_pv;

    /** Most recent value that's being forwarded to server PV */
    private PVAStructure server_data;

    /** @param proxy Proxy that holds this PV
     *  @param name PV name
     *  @param reply_sender Allows sending reply to PVA client that searched for this PV
     */
    ProxiedPV(final Proxy proxy, final String name, final Consumer<InetSocketAddress> reply_sender)
    {
        this.proxy = proxy;
        this.name = name;
        this.reply_sender.set(reply_sender);
        logger.log(Level.FINE, () -> "-------->> Creating " + this);
    }

    /** Start CA client, subscribe to value updates */
    void start() throws Exception
    {
        if (state.compareAndSet(ProxiedPVState.State.Created, ProxiedPVState.State.Started))
        {
            // Create the client PV
            client_pv = PVPool.getPV(name);
            // Subscribe to updates, potentially throttled
            Flowable<VType> flow = client_pv.onValueEvent();
            if (ProxyPreferences.client_throttle_ms > 0)
                flow = flow.throttleLatest(ProxyPreferences.client_throttle_ms, TimeUnit.MILLISECONDS);
            client_sub = flow.subscribe(this::onClientUpdate);
            // On first update, when data type is known, we create the server PV
        }
    }

    /** @return PV name */
    public String getName()
    {
        return name;
    }

    /** @return How long have we been in current state [secs] */
    public double getSecsInState()
    {
        return state.getSecsInState();
    }

    /** @return Is the proxy connected on the client side? */
    public boolean isConnected()
    {
        final PV safe_pv = client_pv;
        if (safe_pv == null)
            return false;
        final VType value = safe_pv.read();
        if (PV.isDisconnected(value))
            return false;
        return true;
    }

    /** @return Is there anybody using the PV on the server side? */
    public boolean isSubscribed()
    {
        final ServerPV save_pv = server_pv;
        return save_pv != null  &&  save_pv.isSubscribed();
    }

    /** Called when receiving value update from client
     *  @param value Value received on client side
     */
    private void onClientUpdate(final VType value)
    {
        proxy.client_update_counter.incrementAndGet();
        proxy.client_update_cache.add(this, value);
    }

    /** Send value out on server side
     *
     *  Called via ClientUpdateCache.
     *  Create PVA PV on first update, then keep updating its value
     *  @param value Value received on client side that should be sent out on server side
     */
    void updateServerSide(final VType value)
    {
        logger.log(Level.FINER, () -> "Client: " + name + " = " + DataUtil.shorten(value, 80) + " [" + state.get() + "]");
        if (state.get() == ProxiedPVState.State.Disposed)
        {
            logger.log(Level.FINER, () -> "Client: " + name + " update ignored, proxy has been disposed");
            return;
        }

        // When core-pv-ca connects to a large array, it will disconnect and then
        // re-connect at a lower priority. As a result, we see an initial 'disconnected' value
        // of type Double(NaN).
        // Soon afterwards we receive the array data.
        // Skip that initial 'disconnected' value!
        // The Proxy's server side does not exist, yet, so no change to our clients.
        // If we did create the proxy's server PV with Double(NaN), the following update
        // with array data would be a type change that's resulting in a disconnect
        // -> connect, disconnect, ... loop
        if (state.get() == ProxiedPVState.State.Started  &&  PV.isDisconnected(value))
        {
            logger.log(Level.FINER, () -> "Client: " + name + " ignored first 'disconnected' value from array re-connect");
            return;
        }

        try
        {
            // If this is the first update, create server PV with that initial value
            if (state.compareAndSet(ProxiedPVState.State.Started, ProxiedPVState.State.FreshServer))
            {
                server_pv = createServerPV(name, value);

                // First time around, send a reply, then release the reply_sender to GC
                final Consumer<InetSocketAddress> rs = reply_sender.getAndSet(null);
                if (rs != null)
                {
                    logger.log(Level.FINE, () -> "---------> Reply to search for " + this);
                    rs.accept(null);
                }
            }
            else
            {
                // Update server's PV data from received value
                DataUtil.update(server_data, value);
                logger.log(Level.FINER, () -> "Sending update : " + DataUtil.shorten(server_data, 80));
                server_pv.update(server_data);
                proxy.server_update_counter.incrementAndGet();

                // Do we have at least one client to our server side?
                // Then we're active
                if (server_pv.isSubscribed())
                    state.set(ProxiedPVState.State.Active);
                else
                    state.set(ProxiedPVState.State.Idle);
            }
        }
        catch (Exception ex)
        {
            logger.log(Level.WARNING, "Cannot update server PV " + name + " for " + DataUtil.shorten(value, 80), ex);
            close();
        }
    }

    /** Create PVA server PV with initial value
     *  @param name PV name
     *  @param value Initial value
     *  @return {@link ServerPV}
     * @throws Exception on error
     */
    private ServerPV createServerPV(final String name, final VType value) throws Exception
    {
        server_data = DataUtil.create(name, value);
        final ServerPV spv = proxy.server.createPV(name, server_data);
        // TODO Set PV to read-only, then update as write access changes
        // client_pv.isReadonly();
        // client_pv.onAccessRightsEvent().subscribe();
        // ... once PVAccess protocol supports read/write access information
        return spv;
    }

    public void close()
    {
        // TODO Correct order of cleanup?

        // Mark as disposed so further client updates will be ignored
        state.set(ProxiedPVState.State.Disposed);

        // Proxy is unused right now, but there could be a new request on the way...
        // Unregister so further requests will create a new proxy
        proxy.forgetProxiedPV(this);

        // Now that this proxy is basically orphaned, stop client ...
        if (client_sub != null)
            client_sub.dispose();
        if (client_pv != null)
            PVPool.releasePV(client_pv);
        // ... then server side (if we got as far as creating one)
        if (server_pv != null)
            server_pv.close();

        logger.log(Level.FINE, () -> "<<-------- Disposed " + this);
    }

    // Hash and compare by name

    @Override
    public int hashCode()
    {
        return name.hashCode();
    }

    @Override
    public boolean equals(Object obj)
    {
        // Shortcut
        if (obj == this)
            return true;
        if (obj instanceof ProxiedPV pv)
            return pv.getName().equals(getName());
        return false;
    }

    @Override
    public String toString()
    {
        return "ProxyPV '" + getName() + "' [" + state.get() + "]";
    }
}
